// @ts-ignore
import sqliteParser from "sqlite-parser";
import { intersection } from "lodash";
// @ts-ignore
import { osqueryTables } from "utilities/osquery_tables";

export type OsqueryPlatform = "darwin" | "windows" | "linux" | "freebsd";

export type ParserResult =
  | "all"
  | "invalid query syntax"
  | "no tables in query AST"
  | "none"
  | OsqueryPlatform;

type PlatformDictionay = Record<string, OsqueryPlatform[]>;

// TODO: Is it ever possible that osquery_tables.json would be missing name or platforms?
interface ITypedTable {
  name: string;
  platforms: Array<OsqueryPlatform | string>;
}

const SUPPORTED_PLATFORMS = ["darwin", "windows", "linux"] as OsqueryPlatform[];

const typedTables = osqueryTables as ITypedTable[];

const platformsByTableDictionary = typedTables.reduce(
  (dictionary, table, i) => {
    const platforms = SUPPORTED_PLATFORMS.filter((p) =>
      table?.platforms?.includes(p)
    );
    dictionary[table.name] = platforms;
    return dictionary;
  },
  {} as PlatformDictionay
);

// The isNode and visit functionality is informed by https://lihautan.com/manipulating-ast-with-javascript/#traversing-an-ast
const _isNode = (node: any) => {
  // TODO: Improve type checking against shape of AST generated by sqliteParser
  return typeof node === "object";
};
const _visit = (abstractSyntaxTree: any, callback: (node: any) => void) => {
  if (abstractSyntaxTree) {
    callback(abstractSyntaxTree);

    Object.keys(abstractSyntaxTree).forEach((key) => {
      const childNode = abstractSyntaxTree[key];
      if (Array.isArray(childNode)) {
        childNode.forEach((grandchildNode) => _visit(grandchildNode, callback));
      } else if (_isNode(childNode)) {
        _visit(childNode, callback);
      }
    });
  }
};

export const listCompatiblePlatforms = (
  parserResults: ParserResult[]
): ParserResult[] => {
  if (parserResults[0] === "invalid query syntax") {
    return parserResults;
  }
  // If query has no tables but is still syntatically valid sql, it is treated as compatible with all platforms
  if (parserResults[0] === "no tables in query AST") {
    return ["all"];
  }
  const compatiblePlatforms = intersection(
    ...parserResults?.map((tableName) => platformsByTableDictionary[tableName])
  );

  return compatiblePlatforms.length ? compatiblePlatforms : ["none"];
};

export const parseSqlTables = (sqlString: string): ParserResult[] => {
  const results = [] as ParserResult[];

  const _callback = (node: any) => {
    if (node) {
      if (node.variant === "recursive") {
        throw new Error(
          "Invalid usage: `recursive` is not supported by `parseSqlTables`"
        );
      } else if (node.variant === "table") {
        results.push(node.name);
      }
    }
  };

  try {
    const sqlTree = sqliteParser(sqlString);
    _visit(sqlTree, _callback);

    return results.length ? results : ["no tables in query AST"];
  } catch (err) {
    // console.log(`Invalid query syntax: ${err.message}\n\n${sqlString}`);

    return ["invalid query syntax"];
  }
};

export default { listCompatiblePlatforms, parseSqlTables };
